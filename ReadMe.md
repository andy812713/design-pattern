# 设计模式是一门艺术,设计模式来源于生活。

# 设计模式在于理解，不在于形式。

# 

## GOF23种设计模式:

###     创建型

​        工厂方法模式
​        抽象工厂模式
​        建造者模式
​        原型模式
​        单例模式

###     结构型

​        适配器模式
​        桥接模式
​        组合模式
​        装饰器模式
​        门面模式
​        享元模式
​        代理模式

##     行为型

​        解释器模式
​        模板方法模式
​        责任链模式
​        命令模式
​        迭代器模式
​        调解者模式
​        备忘录模式
​        挂插着模式
​        状态模式
​        策略模式
​        访问者模式

## Spring中常用的设计模式对比

​    工厂模式        只对结果负责，封装创建过程   BeanFactory、Calender
​    单例模式        保证独一无二               ApplicationContext、Calender
​    原型模式        拔一根猴毛，吹出千万个       ArrayList、PrototypeBean
​    代理模式        找人办事，增强职责          ProxyFactoryBean、JdkDynamicAopProxy、CglibAopProxy
​    委派模式        (项目经理)干活算你的，功劳是我的       DispatcherServlet、BeanDefinitionParserDelegate
​    策略模式        用户选择，结果统一          InstantiationStrategy
​    模板模式        流程标准化，自己实现定制     JdbcTemplate、HttpServlet
​    适配器模式       兼容转换头                 AdvisorAdapter、HandlerAdapter
​    装饰器模式       包装、同宗同源             BufferReader、InputStream、OutputStream、HttpHeadResponseDecorator
​    观察者模式       任务完成时通知             ContextLoaderListener



# 

**工厂模式**：只对结果负责，封装创建过程
**单例模式**：独一无二
**适配器模式**：各种充电器的转接头，110V到220V
**装饰器模式**：套了一层，依旧是is-a的关系
**观察者模式**：发布者和订阅者
**原型模式**：克隆出一个自己来，内存地址不一样
**代理模式**：目的是"增强"原有类的功能
**模板模式**：大流程给你定好，你的工作按我的规矩来。
**委派模式**： "任务分发+工作派遣"，核心是"工作派遣"
**策略模式**：核心是"任务分发"



# 模式对比

## 单例和工厂

   工厂类一般就是被设计为单例。

## 策略和委派

​        策略是委派内部的实现形式，策略关注得失结果是否可以相互替代。
​        委派更关注

### 模版方法和策略

​        1.模版方法和策略模式都有封装算法
​        2.策略模式是使不用算法可以相互替换，且不影响客户端应用层的使用
​        3.模板方法是针对定义一个算法的流程，将一些有细微差异的部分交给子类实现
​        4.模板模式不能改变算法流程，策略模式可以改变算法流程且可以替换。

​                  策略模式通常用来替代if...else...分支语句。

### 装饰者模式和静态代理

​        1.装饰者模式关注点在于给对象动态扩展、添加方法、而代理更加注重控制对对象的方法。
​        2.代理模式通常会在代理类中创建被代理对象的实例，而装饰者模式通常把装饰者作为构造参数。


​    

